// Generated by CoffeeScript 1.4.0

/*
 * Integration tests for the entire IRC client excluding socket logic.
*/


(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  describe('An IRC client front end', function() {
    var client, commandInput, device, getNoticeOption, init, irc, nick, nicks, noticeIsVisible, pressTab, prompt, restart, room, rooms, scriptHandler, switchToWindow, textOfNick, textOfRoom, type, useMocks;
    scriptHandler = client = prompt = commandInput = void 0;
    room = function(index) {
      if (index === -1) {
        return rooms().last();
      }
      return $(rooms()[index]);
    };
    rooms = function() {
      return $('#rooms-container .rooms .room');
    };
    textOfRoom = function(index) {
      return $('.content-item', room(index)).text();
    };
    nick = function(index) {
      if (index === -1) {
        return nicks().last();
      }
      return $(nicks()[index]);
    };
    nicks = function() {
      return $('#nicks-container .nicks .nick');
    };
    textOfNick = function(index) {
      return $('.content-item', nick(index)).text();
    };
    device = function(i) {
      return mocks.RemoteDevice.devices[i];
    };
    irc = function(name) {
      var _ref;
      return (_ref = client.connections[name]) != null ? _ref.irc : void 0;
    };
    type = function(text) {
      var event;
      prompt.val(text);
      event = $.Event('keypress');
      event.which = 13;
      return commandInput._handleKeydown(event);
    };
    pressTab = function() {
      var event;
      event = $.Event('keypress');
      event.which = 9;
      return commandInput._handleGlobalKeydown(event);
    };
    switchToWindow = function(index) {
      return client.switchToWindow(client.winList.get(index));
    };
    noticeIsVisible = function() {
      return $("#notice")[0].style.top === "0px";
    };
    getNoticeOption = function(index) {
      return $("#notice .option" + index);
    };
    restart = function() {
      RemoteDevice.devices = [];
      mocks.dom.tearDown();
      client.tearDown();
      mocks.dom.setUp();
      return init();
    };
    init = function() {
      scriptHandler = new window.script.ScriptHandler;
      client = new window.chat.Chat;
      commandInput.setContext(client);
      commandInput.setKeyboardShortcuts(client.getKeyboardShortcuts());
      scriptHandler.addEventsFrom(client);
      scriptHandler.addEventsFrom(commandInput);
      client.listenToCommands(scriptHandler);
      client.listenToScriptEvents(scriptHandler);
      client.listenToIRCEvents(scriptHandler);
      return client.init();
    };
    useMocks = function() {
      mocks.scripts.useMock();
      mocks.Walkthrough.useMock();
      mocks.Runtime.useMock();
      mocks.storage.useMock();
      mocks.navigator.useMock();
      mocks.ChromeSocket.useMock();
      mocks.RemoteDevice.useMock();
      mocks.Notification.useMock();
      jasmine.Clock.useMock();
      return mocks.dom.setUp();
    };
    beforeEach(function() {
      useMocks();
      prompt = $('#input');
      commandInput = new UserInputHandler(prompt, $(window));
      chrome.storage.sync.set({
        nick: 'ournick'
      });
      return init();
    });
    afterEach(function() {
      mocks.dom.tearDown();
      return client.tearDown();
    });
    it("displays the preferred nick in the status bar", function() {
      return expect($('#status')).toHaveText('ournick');
    });
    it("sets the document title to the version", function() {
      return expect(document.title).toMatch(/^CIRC \d{1,3}\.\d{1,3}\.\d{1,3}/);
    });
    it("initially has one window", function() {
      return expect(rooms().length).toBe(1);
    });
    it("replaces the initial window with a server window on /server", function() {
      type('/server freenode');
      expect(rooms().length).toBe(1);
      expect(textOfRoom(0)).toBe('freenode');
      return expect(client.currentWindow.conn.name).toBe('freenode');
    });
    it("ignores commands that requicre a connection not connected", function() {
      type('/names');
      type('/me is 1337');
      type('/op bob');
      type('/msg someguy');
      return type('/mode sally +o');
    });
    it("displays a prompt internet connectivity is lost", function() {
      expect(noticeIsVisible()).toBe(false);
      mocks.navigator.goOffline();
      return expect(noticeIsVisible()).toBe(true);
    });
    describe("script", function() {
      var add, getMostRecentScriptId, loadScript, waitsForScriptToLoad, waitsForScriptToRespond;
      getMostRecentScriptId = function() {
        return window.script.Script.scriptCount - 1;
      };
      waitsForScriptToRespond = function(event) {
        return waitsFor(function() {
          return scriptHandler[event].calls.length > 0;
        }, 'the script should have sent the given response', 500);
      };
      waitsForScriptToLoad = function(id) {
        return waitsFor(function() {
          var script;
          script = scriptHandler._scripts[id];
          if (!script) {
            return false;
          }
          return script._messagesToHandle.length > 0;
        }, 'the script should have finished loading', 500);
      };
      loadScript = function(sourceCode) {
        var script;
        script = window.script.loader._createScript(sourceCode);
        client.addScript(script);
        waitsForScriptToLoad(script.id);
        return script;
      };
      beforeEach(function() {
        return spyOn(scriptHandler, '_handleMessage').andCallThrough();
      });
      afterEach(function() {
        return $('iframe').remove();
      });
      it("has its name displayed to the user with /scripts", function() {
        loadScript(mocks.scripts.hiSourceCode);
        return runs(function() {
          var message;
          spyOn(client.currentWindow, 'message');
          type('/scripts');
          message = client.currentWindow.message.mostRecentCall.args[1];
          return expect(message.indexOf('/hi')).not.toBe(-1);
        });
      });
      it("can be removed with /uninstall", function() {
        loadScript(mocks.scripts.hiSourceCode);
        return runs(function() {
          expect(__indexOf.call(scriptHandler.getScriptNames(), '/hi') >= 0).toBe(true);
          type('/uninstall /hi');
          return expect(__indexOf.call(scriptHandler.getScriptNames(), '/hi') >= 0).toBe(false);
        });
      });
      it("won't automatically load on startup if it was uninstalled", function() {
        loadScript(mocks.scripts.hiSourceCode);
        return runs(function() {
          var loadedScripts, script, _i, _len, _results;
          type('/uninstall /hi');
          spyOn(window.script.loader, 'loadScriptsFromStorage');
          restart();
          loadedScripts = window.script.loader.loadScriptsFromStorage.mostRecentCall.args[0];
          _results = [];
          for (_i = 0, _len = loadedScripts.length; _i < _len; _i++) {
            script = loadedScripts[_i];
            _results.push(expect(script.sourceCode).not.toBe(mocks.scripts.hiSourceCode));
          }
          return _results;
        });
      });
      it("loads automatically from local storage on startup if previously loaded", function() {
        loadScript(mocks.scripts.hiSourceCode);
        return runs(function() {
          restart();
          waitsForScriptToLoad(getMostRecentScriptId());
          return runs(function() {
            return expect(__indexOf.call(scriptHandler.getScriptNames(), '/hi') >= 0).toBe(true);
          });
        });
      });
      it("loads automatically on startup if prepackaged", function() {
        waitsForScriptToLoad(0);
        return runs(function() {
          return expect(__indexOf.call(scriptHandler.getScriptNames(), '/dance') >= 0).toBe(true);
        });
      });
      it("loads from local storage on subsequent runs if prepackaged", function() {
        spyOn(window.script.loader, 'loadPrepackagedScripts');
        restart();
        expect(window.script.loader.loadPrepackagedScripts).not.toHaveBeenCalled();
        waitsForScriptToLoad(1);
        return runs(function() {
          return expect(__indexOf.call(scriptHandler.getScriptNames(), '/dance') >= 0).toBe(true);
        });
      });
      add = function(amount, onFinish) {
        type('/add ' + amount);
        waitsForScriptToRespond('_emitEvent');
        return runs(function() {
          var event;
          event = scriptHandler._emitEvent.mostRecentCall.args[0];
          scriptHandler._emitEvent.reset();
          return typeof onFinish === "function" ? onFinish(event) : void 0;
        });
      };
      it("can save and load information to sync storage", function() {
        loadScript(mocks.scripts.storageSourceCode);
        return runs(function() {
          spyOn(scriptHandler, '_emitEvent');
          return add(5, function(event) {
            expect(event.args[0]).toBe('Sum so far: ' + 5);
            return add(7, function(event) {
              expect(event.args[0]).toBe('Sum so far: ' + 12);
              $('iframe').remove();
              restart();
              waitsForScriptToLoad(window.script.prepackagedScripts.length + 1);
              return runs(function() {
                spyOn(scriptHandler, '_emitEvent');
                return add(8, function(event) {
                  return expect(event.args[0]).toBe('Sum so far: ' + 20);
                });
              });
            });
          });
        });
      });
      it("has its sync storage data erased when uninstalled", function() {
        loadScript(mocks.scripts.storageSourceCode);
        return runs(function() {
          spyOn(scriptHandler, '_emitEvent').andCallThrough();
          return add(5, function(event) {
            expect(event.args[0]).toBe('Sum so far: ' + 5);
            return chrome.storage.sync.get('script_sum', function(state) {
              expect(state.script_sum).toBe(5);
              type('/uninstall sum');
              return chrome.storage.sync.get('script_sum', function(state) {
                return expect(state.script_sum).not.toBeDefined();
              });
            });
          });
        });
      });
      it("is notified when its storage changes", function() {
        loadScript(mocks.scripts.storageSourceCode);
        return runs(function() {
          spyOn(scriptHandler, '_emitEvent').andCallThrough();
          window.chrome.storage.update({
            script_sum: {
              newValue: 15,
              oldValue: 0
            }
          });
          return add(5, function(event) {
            return expect(event.args[0]).toBe('Sum so far: ' + 20);
          });
        });
      });
      return describe('has a name which', function() {
        it("is always unique name", function() {
          var script1, script2;
          script1 = loadScript(mocks.scripts.hiSourceCode);
          script2 = loadScript(mocks.scripts.hiSourceCode);
          return runs(function() {
            expect(script1.getName()).toBe('/hi');
            return expect(script2.getName()).toBe('/hi2');
          });
        });
        it("can only contain valid characters", function() {
          var script;
          script = loadScript(mocks.scripts.invalidNameSourceCode);
          return runs(function() {
            return expect(script.getName()).not.toBe('invalid name');
          });
        });
        it("has a max length", function() {
          var script;
          script = loadScript(mocks.scripts.longNameSourceCode);
          return runs(function() {
            console.log(script.getName());
            return expect(script.getName().length <= 20).toBe(true);
          });
        });
        return it("has a default name of script#", function() {
          var script;
          script = loadScript(mocks.scripts.noNameSourceCode);
          return runs(function() {
            return expect(script.getName()).toMatch(/script\d+/);
          });
        });
      });
    });
    describe("walkthrough", function() {
      var restartWith, walkthrough;
      walkthrough = void 0;
      beforeEach(function() {
        return walkthrough = mocks.Walkthrough.instance;
      });
      restartWith = function(obj, type) {
        if (type == null) {
          type = 'sync';
        }
        chrome.storage.sync.clear();
        chrome.storage.local.clear();
        chrome.storage[type].set(obj);
        restart();
        return walkthrough = mocks.Walkthrough.instance;
      };
      it("walks the user through the basics of setting a nick and connecting to a channel", function() {
        restartWith();
        expect(walkthrough._startWalkthrough).toHaveBeenCalled();
        expect(walkthrough._serverWalkthrough).not.toHaveBeenCalled();
        type('/nick ournick');
        expect(walkthrough._serverWalkthrough).toHaveBeenCalled();
        expect(walkthrough._channelWalkthrough).not.toHaveBeenCalled();
        type('/server freenode');
        irc('freenode').handle('1', {}, 'ournick');
        expect(walkthrough._channelWalkthrough).toHaveBeenCalled();
        expect(walkthrough._endWalkthrough).not.toHaveBeenCalled();
        type('/join #bash');
        irc('freenode').handle('JOIN', {
          nick: 'ournick'
        }, '#bash');
        return expect(walkthrough._endWalkthrough).toHaveBeenCalled();
      });
      it("doesn't start the walkthrough if the user has completed it", function() {
        restartWith({
          'completed_walkthrough': true
        }, 'local');
        return expect(walkthrough._startWalkthrough).not.toHaveBeenCalled();
      });
      it("jumps to 2nd step in walkthrough if nick is already set", function() {
        restartWith({
          'nick': 'ournick'
        });
        expect(walkthrough._startWalkthrough).not.toHaveBeenCalled();
        return expect(walkthrough._serverWalkthrough).toHaveBeenCalled();
      });
      it("jumps to 3rd step in walkthrough if a server is stored, but don't display it until connected to the server", function() {
        restartWith({
          'servers': [
            {
              name: 'freenode',
              port: 6667
            }
          ]
        });
        expect(walkthrough._startWalkthrough).not.toHaveBeenCalled();
        expect(walkthrough._serverWalkthrough).not.toHaveBeenCalled();
        expect(walkthrough._channelWalkthrough).not.toHaveBeenCalled();
        irc('freenode').handle('1', {}, 'ournick');
        return expect(walkthrough._channelWalkthrough).toHaveBeenCalled();
      });
      return it("doesn't show the walkthrough if a channel is stored", function() {
        restartWith({
          servers: [
            {
              name: 'freenode',
              port: 6667
            }
          ],
          channels: [
            {
              name: '#bash',
              server: 'freenode'
            }
          ]
        });
        expect(walkthrough._startWalkthrough).not.toHaveBeenCalled();
        expect(walkthrough._serverWalkthrough).not.toHaveBeenCalled();
        expect(walkthrough._channelWalkthrough).not.toHaveBeenCalled();
        return expect(walkthrough._channelWalkthrough).not.toHaveBeenCalled();
      });
    });
    describe("storage", function() {
      var doActivity;
      doActivity = function() {
        type('/nick newNick');
        type('/server freenode 6667');
        type('/join #bash');
        type('/join #awesome');
        type('/server dalnet 6697');
        return type('/join #hiphop');
      };
      beforeEach(function() {
        return doActivity();
      });
      it("chooses a new password when one doesn't currently exist", function() {
        return expect(client.remoteConnection._password).toEqual(jasmine.any(String));
      });
      it("keeps the old password when one exists", function() {
        chrome.storage.sync.set({
          password: 'bob'
        });
        restart();
        return expect(client.remoteConnection._password).toBe('bob');
      });
      it("restores the previously used nick", function() {
        restart();
        return runs(function() {
          return expect($('#status')).toHaveText('newNick');
        });
      });
      it("generates random nick when no previously used nick is available", function() {
        chrome.storage.sync.set({
          nick: void 0
        });
        restart();
        type("/connect freenode");
        return expect(irc('freenode').preferredNick).toBeDefined();
      });
      it("restores the previously joined servers", function() {
        restart();
        expect(client.connections['freenode']).toBeDefined();
        return expect(client.connections['dalnet']).toBeDefined();
      });
      it("restores the previously joined channels", function() {
        restart();
        expect(client.connections['freenode'].windows['#bash']).toBeDefined();
        expect(client.connections['freenode'].windows['#awesome']).toBeDefined();
        expect(client.connections['dalnet'].windows['#hiphop']).toBeDefined();
        return expect(rooms().length).toBe(5);
      });
      it("selects the first room when restoring previous channels and servers", function() {
        restart();
        return expect(room(0)).toHaveClass('selected');
      });
      it("doesn't restore channels that were parted", function() {
        type('/part #hiphop');
        restart();
        expect(client.connections['dalnet'].windows['#hiphop']).not.toBeDefined();
        return expect(rooms().length).toBe(4);
      });
      it("doesn't restore servers that were parted", function() {
        switchToWindow(0);
        type('/quit');
        restart();
        expect(irc('freenode')).not.toBeDefined();
        return expect(rooms().length).toBe(2);
      });
      return it("displays restored private channels as connected", function() {
        irc('freenode').handle('1', {}, 'ournick');
        irc('freenode').handle('PRIVMSG', {
          nick: 'someguy'
        }, 'ournick', 'hi there');
        restart();
        expect(rooms().length).toBe(6);
        expect(textOfRoom(3)).toBe('someguy');
        return expect(room(3)).not.toHaveClass('disconnected');
      });
    });
    describe("that is connecting", function() {
      beforeEach(function() {
        type('/server freenode');
        return expect(irc('freenode').state).toBe('connecting');
      });
      it('can queue a disconnection request with /quit', function() {
        var currentIRC;
        currentIRC = irc('freenode');
        type('/quit');
        currentIRC.handle('1', {}, 'ournick');
        return expect(currentIRC.state).toBe('disconnected');
      });
      it('allows channels to be joined while connecting', function() {
        type('/join #bash');
        expect(rooms().length).toBe(2);
        expect(textOfRoom(-1)).toBe('#bash');
        expect(room(-1)).toHaveClass('selected');
        return expect(room(-1)).toHaveClass('disconnected');
      });
      it('automatically joins queued channels when connected', function() {
        type('/join #bash');
        type('/part');
        spyOn(irc('freenode'), 'send');
        irc('freenode').handle('1', {}, 'ournick');
        return expect(irc('freenode').send).not.toHaveBeenCalled();
      });
      return it('removes queued channels on /part', function() {
        type('/join #bash');
        spyOn(irc('freenode'), 'send');
        irc('freenode').handle('1', {}, 'ournick');
        return expect(irc('freenode').send).toHaveBeenCalledWith('JOIN', '#bash');
      });
    });
    return describe("that connects", function() {
      var currentIRC;
      currentIRC = void 0;
      beforeEach(function() {
        type('/server freenode');
        currentIRC = irc('freenode');
        currentIRC.handle('1', {}, 'ournick');
        expect(currentIRC.state).toBe('connected');
        return spyOn(currentIRC, 'doCommand');
      });
      it("marks the server item in the window list as connected", function() {
        return expect(room(0)).not.toHaveClass('disconnected');
      });
      it("updates the status bar on /away", function() {
        type('/away');
        currentIRC.handle('306');
        return expect($('#status')).toHaveText('ournick' + 'away');
      });
      it("creates a new window when a direct private message is received", function() {
        currentIRC.handle('PRIVMSG', {
          nick: 'someguy'
        }, 'ournick', 'hi there');
        expect(rooms().length).toBe(2);
        expect(textOfRoom(-1)).toBe('someguy');
        expect(room(-1)).toHaveClass('mention');
        expect(room(-1)).toHaveClass('activity');
        return expect(room(-1)).not.toHaveClass('selected');
      });
      it("displays /msg text in the current window if there is no existing conversation window", function() {
        spyOn(client.currentWindow, 'message').andCallThrough();
        type('/msg someguy hey dude');
        expect(rooms().length).toBe(1);
        return expect(client.currentWindow.message).toHaveBeenCalled();
      });
      it("displays /msg text in the conversation window when it exists", function() {
        currentIRC.handle('PRIVMSG', {
          nick: 'someguy'
        }, 'ournick', 'hi there');
        spyOn(client.currentWindow, 'message').andCallThrough();
        type('/msg someguy hey dude');
        return expect(client.currentWindow.message).not.toHaveBeenCalled();
      });
      it("/msg causes the conversation window to be marked with activity", function() {
        currentIRC.handle('PRIVMSG', {
          nick: 'someguy'
        }, 'ournick', 'hi there');
        switchToWindow(1);
        switchToWindow(0);
        expect(room(-1)).not.toHaveClass('mention');
        expect(room(-1)).not.toHaveClass('activity');
        expect(room(-1)).not.toHaveClass('selected');
        type('/msg someguy hey dude');
        expect(room(-1)).not.toHaveClass('mention');
        expect(room(-1)).toHaveClass('activity');
        return expect(room(-1)).not.toHaveClass('selected');
      });
      it("can join a channel with /join", function() {
        type('/join #bash');
        expect(currentIRC.doCommand).toHaveBeenCalledWith('JOIN', '#bash');
        return expect(client.currentWindow.target).toBe('#bash');
      });
      describe("then is disconnected by a socket error", function() {
        beforeEach(function() {
          return currentIRC.onClose();
        });
        it('shows all servers and channels as disconnected', function() {
          return expect(room(0)).toHaveClass('disconnected');
        });
        it('attempts to reconnect after a short amount of time', function() {
          spyOn(currentIRC, 'connect');
          jasmine.Clock.tick(2000);
          return expect(currentIRC.connect).toHaveBeenCalled();
        });
        it('uses exponential backoff for reconnection attempts', function() {
          jasmine.Clock.tick(2000);
          currentIRC.onError('socket error!');
          spyOn(currentIRC, 'connect');
          jasmine.Clock.tick(2000);
          expect(currentIRC.connect).not.toHaveBeenCalled();
          jasmine.Clock.tick(2000);
          expect(currentIRC.connect).toHaveBeenCalled();
          currentIRC.connect.reset();
          currentIRC.onError('socket error!');
          jasmine.Clock.tick(7999);
          return expect(currentIRC.connect).not.toHaveBeenCalled();
        });
        return it('closes the current window and stops reconnecting on /quit', function() {
          type("/quit");
          expect(client.currentWindow.name).toBe('none');
          spyOn(currentIRC, 'connect');
          jasmine.Clock.tick(9000);
          return expect(currentIRC.connect).not.toHaveBeenCalled();
        });
      });
      return describe("then joins a channel", function() {
        beforeEach(function() {
          type('/join #bash');
          return currentIRC.handle('JOIN', {
            nick: 'ournick'
          }, '#bash');
        });
        it("adds another item to the room display", function() {
          return expect(rooms().length).toBe(2);
        });
        it("can switch channels with /win", function() {
          type('/join #zebra');
          expect(room(1)).not.toHaveClass('selected');
          expect(room(2)).toHaveClass('selected');
          type("/win 1");
          expect(room(1)).toHaveClass('selected');
          return expect(room(2)).not.toHaveClass('selected');
        });
        it("marks a window as active if a message is sent and it's not selected", function() {
          var irc2;
          type('/server dalnet');
          irc2 = client.currentWindow.conn.irc;
          irc2.handle('1', {}, 'ournick');
          currentIRC.handle('PRIVMSG', {
            nick: 'someguy'
          }, '#bash', 'hi');
          return expect(room(1)).toHaveClass('activity');
        });
        it("clears activity and mention style when switching to a window", function() {
          switchToWindow(0);
          currentIRC.handle('PRIVMSG', {
            nick: 'someguy'
          }, '#bash', 'hey!');
          switchToWindow(1);
          expect(room(1)).not.toHaveClass('mention');
          expect(room(1)).not.toHaveClass('activity');
          return expect(room(1)).toHaveClass('selected');
        });
        it("clicking on a channel in the channel display switches to that channel", function() {
          switchToWindow(0);
          expect(room(1)).not.toHaveClass('selected');
          client.channelDisplay.emit('clicked', 'freenode', '#bash');
          expect(client.currentWindow.target).toBe('#bash');
          return expect(room(1)).toHaveClass('selected');
        });
        it("hitting tab with empty input fills in the name of the last user to mention the user", function() {
          currentIRC.handle('PRIVMSG', {
            nick: 'someguy'
          }, '#bash', 'hey ournick!');
          pressTab();
          return expect($("#input")).toHaveValue('someguy: ');
        });
        it("can ignore part and join messages with '/ignore part join'", function() {
          type('/ignore part join');
          spyOn(client.currentWindow, 'message').andCallThrough();
          currentIRC.handle('JOIN', {
            nick: 'someguy'
          }, '#bash');
          expect(client.currentWindow.message).not.toHaveBeenCalled();
          currentIRC.handle('PART', {
            nick: 'someguy'
          }, '#bash');
          return expect(client.currentWindow.message).not.toHaveBeenCalled();
        });
        it("can unignore part and join messages with '/unignore part join'", function() {
          type('/ignore part join');
          type('/unignore part join');
          spyOn(client.currentWindow, 'message').andCallThrough();
          currentIRC.handle('JOIN', {
            nick: 'someguy'
          }, '#bash');
          expect(client.currentWindow.message).toHaveBeenCalled();
          currentIRC.handle('PART', {
            nick: 'someguy'
          }, '#bash');
          return expect(client.currentWindow.message).toHaveBeenCalled();
        });
        describe("can display desktop notifications which", function() {
          it("display when a direct private message is received", function() {
            currentIRC.handle('PRIVMSG', {
              nick: 'someguy'
            }, 'ournick', 'hey!');
            return expect(mocks.Notification.numActive).toBe(1);
          });
          it("display when the user's nick is mentioned", function() {
            switchToWindow(0);
            currentIRC.handle('PRIVMSG', {
              nick: 'someguy'
            }, '#bash', 'hey ournick!');
            expect(mocks.Notification.numActive).toBe(1);
            expect(room(-1)).toHaveClass('mention');
            expect(room(-1)).toHaveClass('activity');
            return expect(room(-1)).not.toHaveClass('selected');
          });
          it("group when there are multiple notifications for the same channel", function() {
            currentIRC.handle('PRIVMSG', {
              nick: 'someguy'
            }, 'ournick', 'hey!');
            currentIRC.handle('PRIVMSG', {
              nick: 'someguy'
            }, 'ournick', 'hi!');
            return expect(mocks.Notification.numActive).toBe(1);
          });
          return it("don't group when there are multiple notifications for different channels", function() {
            switchToWindow(0);
            currentIRC.handle('PRIVMSG', {
              nick: 'someguy'
            }, '#bash', 'hey ournick!');
            currentIRC.handle('PRIVMSG', {
              nick: 'someguy'
            }, 'ournick', 'hey!');
            return expect(mocks.Notification.numActive).toBe(2);
          });
        });
        describe("has a nick list which", function() {
          var addNicks, currentNicks;
          currentNicks = void 0;
          beforeEach(function() {
            return currentNicks = ['bart', 'bill', 'bob', 'charlie', 'derek', 'edward', 'jacob', 'megan', 'norman', 'sally', 'sue', 'Tereza', 'zabo1', 'ZABO2', 'zabo3', 'Zabo88'];
          });
          addNicks = function() {
            var name, nameMap, _i, _len;
            currentIRC.emit('names', '#bash', currentNicks.slice(0, 7));
            currentIRC.emit('names', '#bash', currentNicks.slice(7, 12));
            currentIRC.emit('names', '#bash', currentNicks.slice(12));
            nameMap = {};
            for (_i = 0, _len = currentNicks.length; _i < _len; _i++) {
              name = currentNicks[_i];
              nameMap[name] = name;
            }
            return currentIRC.channels['#bash'].names = nameMap;
          };
          it("displays the user's nick when first joining a channel", function() {
            expect(nicks().length).toBe(1);
            return expect(textOfNick(0)).toBe('ournick');
          });
          it("displays all nicks in the channel when the nick list is sent", function() {
            addNicks();
            return expect(nicks().length).toBe(currentNicks.length + 1);
          });
          it("displays nicks in sorted order", function() {
            addNicks();
            return expect(textOfNick(9)).toBe('ournick');
          });
          it("displays newly joined nicks after they /join", function() {
            addNicks();
            currentIRC.handle('JOIN', {
              nick: 'alphy'
            }, '#bash');
            expect(nicks().length).toBe(currentNicks.length + 2);
            return expect(textOfNick(0)).toBe('alphy');
          });
          it("doesn't display nicks after they have been kicked", function() {
            addNicks();
            currentIRC.handle('KICK', {
              nick: 'bob'
            }, '#bash', 'Zabo88');
            expect(nicks().length).toBe(currentNicks.length);
            return expect(textOfNick(0)).not.toBe('Zabo88');
          });
          it("doesn't display nicks after they left with /parted", function() {
            addNicks();
            currentIRC.handle('PART', {
              nick: 'bob'
            }, '#bash');
            expect(nicks().length).toBe(currentNicks.length);
            return expect(textOfNick(2)).not.toBe('bob');
          });
          it("doesn't display duplicate nicks", function() {
            currentNicks.push('ournick');
            addNicks();
            return expect(nicks().length).toBe(currentNicks.length);
          });
          return it("stays visible when another non-selected window is closed", function() {
            var event;
            type("/join #awesome");
            event = new Event('command', 'part');
            event.setContext('freenode', '#bash');
            client.userCommands.handle('part', event);
            return expect($('#rooms-and-nicks')).not.toHaveClass('no-nicks');
          });
        });
        return describe("with a remote connection", function() {
          var authenticate, becomeClient, findPort, getChannels, getState, onAuth, receiveChatHistory, receivePassword, state;
          state = onAuth = void 0;
          getChannels = function() {
            return {
              '#bash': {
                names: {
                  sally: 'Sally',
                  bob: 'bob',
                  somenick: 'somenick'
                }
              }
            };
          };
          getState = function() {
            return {
              nick: 'preferredNick',
              servers: [
                {
                  name: 'freenode',
                  port: 6667
                }, {
                  name: 'dalnet',
                  port: 6697
                }
              ],
              channels: [
                {
                  name: '#bash',
                  server: 'freenode'
                }, {
                  name: '#awesome',
                  server: 'dalnet'
                }
              ],
              ircStates: [
                {
                  server: 'freenode',
                  state: 'connected',
                  nick: 'somenick',
                  away: true,
                  channels: getChannels()
                }
              ]
            };
          };
          findPort = function() {
            var d;
            d = client.remoteConnection._thisDevice;
            d.port = 1;
            RemoteDevice.state = 'found_port';
            return d.emit('found_port');
          };
          authenticate = function(device) {
            var authToken;
            authToken = client.remoteConnection._getAuthToken(device.password);
            return device.emit('authenticate', device, authToken);
          };
          receivePassword = function(device, password) {
            return device.emit('authentication_offer', device, password);
          };
          becomeClient = function(opt_state) {
            if (opt_state) {
              state = opt_state;
            }
            return (device(1)).emit('connection_message', device(1), 'irc_state', state);
          };
          receiveChatHistory = function(chatHistory) {
            return device(1).emit('connection_message', device(1), 'chat_log', chatHistory);
          };
          beforeEach(function() {
            state = getState();
            return spyOn(mocks.RemoteDevice, 'onConnect').andCallThrough();
          });
          it("connects to a server device with /join-server", function() {
            type("/join-server 1.1.1.2 1336");
            return expect(mocks.RemoteDevice.onConnect).toHaveBeenCalled();
          });
          it("emits 'server_found' when server sends a password", function() {
            type("/join-server 1.1.1.2 1336");
            spyOn(client.remoteConnection, 'emit');
            receivePassword(device(1), 'pw');
            return expect(client.remoteConnection.emit).toHaveBeenCalledWith('server_found', device(1));
          });
          it("sends authentication after server sends a password and finalizeConnection() is called", function() {
            type("/join-server 1.1.1.2 1336");
            receivePassword(device(1), 'pw');
            return expect(device(1).sendType).toBe('authenticate');
          });
          it("becomes a client after receiving IRC state", function() {
            type("/join-server 1.1.1.2 1336");
            expect(client.remoteConnection.isClient()).toBe(false);
            becomeClient([]);
            return expect(client.remoteConnection.isClient()).toBe(true);
          });
          it("doesn't add a client before authentication", function() {
            RemoteDevice.onNewDevice(new RemoteDevice);
            return expect(client.remoteConnection.devices[0]).not.toBeDefined();
          });
          it("add a client after it authenticates", function() {
            RemoteDevice.onNewDevice(new RemoteDevice);
            expect(client.remoteConnection.devices[0]).not.toBeDefined();
            authenticate(device(1));
            return expect(client.remoteConnection.devices[0]).toBeDefined();
          });
          it("disconnects from the current connection before using the server device's connection", function() {
            type("/join-server 1.1.1.2 1336");
            becomeClient([]);
            expect(rooms().length).toBe(1);
            return expect(client.connections['freenode']).not.toBeDefined();
          });
          it("can load the IRC state from the server device", function() {
            var i, name, _i, _len, _ref;
            type("/join-server 1.1.1.2 1336");
            becomeClient();
            expect(rooms().length).toBe(4);
            expect(irc('freenode').state).toBe('connected');
            expect(irc('dalnet').state).toBe('disconnected');
            expect(room(0)).not.toHaveClass('disconnected');
            expect(room(1)).not.toHaveClass('disconnected');
            expect(room(2)).toHaveClass('disconnected');
            expect(room(3)).toHaveClass('disconnected');
            type(switchToWindow(1));
            _ref = ['bob', 'Sally', 'somenick'];
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              name = _ref[i];
              expect(textOfNick(i)).toBe(name);
            }
            return expect($('#status').text()).toBe('somenick' + 'away');
          });
          it("doesn't set the irc nick if the nick isn't saved", function() {
            type("/join-server 1.1.1.2 1336");
            state.ircStates[0].nick = void 0;
            state.nick = void 0;
            becomeClient();
            return expect(irc('freenode').preferredNick).toBeDefined();
          });
          it("can listen to user input from the server device", function() {
            var event;
            type("/join-server 1.1.1.2 1336");
            becomeClient();
            event = new Event('command', 'nick', 'newnick');
            event.setContext('freenode');
            spyOn(client, 'setNick');
            (device(1)).emit('user_input', device(1), event);
            return expect(client.setNick).toHaveBeenCalledWith('freenode', 'newnick');
          });
          it("can listen to socket data from the server device", function() {
            type("/join-server 1.1.1.2 1336");
            becomeClient();
            spyOn(irc('freenode'), 'onDrain');
            (device(1)).emit('socket_data', device(1), 'freenode', 'drain');
            return expect(irc('freenode').onDrain).toHaveBeenCalled();
          });
          it("uses own connection after connection to the server is lost", function() {
            type("/join-server 1.1.1.2 1336");
            becomeClient([]);
            spyOn(client, 'closeAllConnections');
            (device(1)).emit('closed', device(1));
            expect(client.remoteConnection.isIdle()).toBe(true);
            return expect(client.closeAllConnections).toHaveBeenCalled();
          });
          it("on startup, when server exists, uses own connection after waiting a brief time", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            delete state.ircState;
            chrome.storage.sync.set(state);
            restart();
            expect(rooms().length).toBe(1);
            jasmine.Clock.tick(2000);
            return expect(rooms().length).toBe(4);
          });
          it("automatically connects if an existing server is present", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            restart();
            return expect(mocks.RemoteDevice.onConnect).toHaveBeenCalled();
          });
          it("becomes server if storage marks it as the server device", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.1',
                port: 1
              }
            });
            restart();
            findPort();
            return expect(client.remoteConnection.isServer()).toBe(true);
          });
          it("updates stored server device info when the server device's port changes", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.1',
                port: 2
              }
            });
            restart();
            findPort();
            expect(client.remoteConnection.isServer()).toBe(true);
            return expect(chrome.storage.sync._storageMap.server_device.port).toBe(1);
          });
          it("becomes idle if can't connect to server device", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            restart();
            expect(client.remoteConnection.getState()).toBe('connecting');
            mocks.RemoteDevice.willConnect = false;
            restart();
            return expect(client.remoteConnection.isIdle()).toBe(true);
          });
          it("keeps trying to connect to the server device", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            restart();
            mocks.RemoteDevice.willConnect = false;
            restart();
            mocks.RemoteDevice.willConnect = true;
            jasmine.Clock.tick(1000);
            return expect(client.remoteConnection.getState()).toBe('connecting');
          });
          it("forwards user input to connected clients when acting as the server device", function() {
            findPort();
            type('/make-server');
            RemoteDevice.onNewDevice(new RemoteDevice);
            authenticate(device(1));
            RemoteDevice.onNewDevice(new RemoteDevice);
            authenticate(device(2));
            expect(client.remoteConnection.devices.length).toBe(2);
            spyOn(device(1), 'send');
            spyOn(device(2), 'send');
            spyOn(client.remoteConnection, 'emit');
            device(1).emit('user_input', device(1), {
              type: 'command',
              name: 'say',
              args: ['hi guys'],
              context: {
                server: 'freenode',
                channel: '#bash'
              }
            });
            expect(device(1).send).not.toHaveBeenCalled();
            expect(device(2).send.mostRecentCall.args[0]).toBe('user_input');
            return expect(client.remoteConnection.emit).toHaveBeenCalledWith('command', jasmine.any(Event));
          });
          it("only sends IRC state to the connecting device, not all devices", function() {
            findPort();
            type('/make-server');
            RemoteDevice.onNewDevice(new RemoteDevice);
            authenticate(device(1));
            RemoteDevice.onNewDevice(new RemoteDevice);
            spyOn(device(1), 'send');
            spyOn(device(2), 'send');
            authenticate(device(2));
            expect(device(2).send).toHaveBeenCalled();
            return expect(device(1).send).not.toHaveBeenCalled();
          });
          it("retains connections after /make-server", function() {
            findPort();
            expect(rooms().length).toBe(2);
            type("/make-server");
            return expect(rooms().length).toBe(2);
          });
          it("is able to connect to servers even if chrome.socket.listen isn't supported", function() {
            chrome.socket.listen = void 0;
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            restart();
            return expect(client.remoteConnection.getState()).toBe('connecting');
          });
          it("can't become a server if chrome.socket.listen isn't defined", function() {
            chrome.socket.listen = void 0;
            type("/make-server");
            return expect(client.remoteConnection.isIdle()).toBe(true);
          });
          it("sends chat history when a client connects", function() {
            findPort();
            type("/make-server");
            RemoteDevice.onNewDevice(new RemoteDevice);
            spyOn(device(1), 'send');
            type('hi there');
            authenticate(device(1));
            return expect(device(1).send).toHaveBeenCalledWith('connection_message', ['chat_log', jasmine.any(Object)]);
          });
          it("replays received chat history after connecting to a server device", function() {
            var chatHistory, win;
            type('hi there');
            type('i am recording some chat history');
            chatHistory = client.messageHandler.getChatLog();
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            restart();
            becomeClient();
            win = client.winList.get('freenode', '#bash');
            spyOn(win, 'rawHTML');
            receiveChatHistory(chatHistory);
            expect(client.remoteConnection.isClient()).toBe(true);
            return expect(win.rawHTML).toHaveBeenCalled();
          });
          it("connects to a server even when the server connection takes a long time", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            delete state.ircState;
            chrome.storage.sync.set(state);
            restart();
            jasmine.Clock.tick(900);
            spyOn(client.remoteConnection, 'finalizeConnection').andCallThrough();
            receivePassword(device(1), 'pw');
            expect(client.remoteConnection.finalizeConnection).toHaveBeenCalled();
            return expect(client.remoteConnection.getState()).toBe('connecting');
          });
          it("displays a prompt when connecting to the server device would be abrupt", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            delete state.ircState;
            chrome.storage.sync.set(state);
            restart();
            client.remoteConnectionHandler._timer.elapsed = function() {
              return 5000;
            };
            jasmine.Clock.tick(5000);
            spyOn(client.remoteConnection, 'finalizeConnection');
            receivePassword(device(1), 'pw');
            expect(client.remoteConnection.finalizeConnection).not.toHaveBeenCalled();
            return expect(noticeIsVisible()).toBe(true);
          });
          it("closes sockets when internect connection is lost", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            delete state.ircState;
            chrome.storage.sync.set(state);
            restart();
            becomeClient();
            spyOn(device(1), 'close');
            mocks.navigator.goOffline();
            expect(noticeIsVisible()).toBe(true);
            return expect(device(1).close).toHaveBeenCalled();
          });
          it("establishes connection when internet is re-enabled", function() {
            chrome.storage.sync.set({
              server_device: {
                addr: '1.1.1.2',
                port: 1
              }
            });
            delete state.ircState;
            chrome.storage.sync.set(state);
            restart();
            becomeClient();
            mocks.navigator.goOffline();
            expect(client.remoteConnection.getState()).not.toBe('connecting');
            expect(noticeIsVisible()).toBe(true);
            mocks.navigator.goOnline();
            return expect(client.remoteConnection.getState()).toBe('connecting');
          });
          return it("prompts the user to update when a newer version of CIRC is available", function() {
            chrome.runtime.updateAvailable();
            expect(noticeIsVisible()).toBe(true);
            getNoticeOption(1).click();
            return expect(chrome.runtime.reload).toHaveBeenCalled();
          });
        });
      });
    });
  });

}).call(this);

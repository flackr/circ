// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";
  var _ref, _ref1, _ref2, _this = this;
  var openTcpServers = [];
  var openConnections = [];
  var currentApp = null;
  var exports = window || {};

  var appIsRunning = function() {
    return currentApp && !currentApp.contentWindow.closed;
  };

  var cleanup = function() {
    for (var socketid in openConnections) {
      chrome.sockets.tcp.disconnect(parseInt(socketid));
      chrome.sockets.tcp.close(parseInt(socketid));
    }
    openConnections = [];

    for (var socketid in openTcpServers) {
      chrome.sockets.tcpServer.disconnect(parseInt(socketid));
      chrome.sockets.tcp.close(parseInt(socketid));
    }
    openTcpServers = [];
    window.close();
  }

  exports.registerSocketId = function(socketid) {
    openConnections[socketid] = true;
  }

  exports.unregisterSocketId = function(socketid) {
    delete openConnections[socketid];
  }

  exports.registerTcpServer = function (socketid) {
    openTcpServers[socketid] = true;
  }

  exports.unregisterTcpServer = function (socketid) {
    delete openTcpServers[socketid];
  }

  var onCreated = function (win) {
    var _ref;
    currentApp = win;
    if (win.onClosed)
      win.onClosed.addListener(function() {
        cleanup();
      });
  };

  var create = function() {
    return chrome.app.window.create('bin/main.html', {
      width: 775,
      height: 400,
      minWidth: 320,
      minHeight: 160,
      id: 'circ'
    }, onCreated);
  };

  if ((_ref = chrome.runtime.onStartup) != null) {
    _ref.addListener(function() {
      return chrome.storage.sync.get('autostart', function(storageMap) {
        if (storageMap.autostart) {
          create();
        } else {
          if (!appIsRunning()) {
            window.close();
          }
        }
      });
    });
  }

  if ((_ref1 = chrome.app.runtime.onLaunched) != null) {
    _ref1.addListener(function() {
      if (appIsRunning()) {
        return currentApp.focus();
      } else {
        return create();
      }
    });
  }

  /*
   * Repeatedly check if the window has been closed and close the background page
   * when it has.
   * TODO: Take this out once the onClose event hits stable.
  */
  var closeWhenAppCloses = function() {
    var _this = this;
    var interval = setInterval(function() {
      if (!appIsRunning()) {
        clearInterval(interval);
        cleanup();
      }
    }, 1000);
  };

  if ((_ref2 = chrome.runtime.onUpdateAvailable) != null) {
    _ref2.addListener(function() {
      if (chrome.runtime.reload == null) {
        return;
      }
      if (appIsRunning()) {
        return closeWhenAppCloses();
      } else {
        return window.close();
      }
    });
  }

}).call(this);

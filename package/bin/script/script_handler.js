// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";
  var ScriptHandler, exports, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  var exports = (_ref = window.script) != null ? _ref : window.script = {};

  /*
   * Handles currently running scripts. Events sent from the user and IRC servers
   * are intercepted by this class, passed to scripts, and then forwarded on to
   * their destination.
   */
  ScriptHandler = (function(_super) {

    __extends(ScriptHandler, _super);

    /*
     * Script names that are longer this this are truncated.
     */
    ScriptHandler.MAX_NAME_LENGTH = 20;

    /*
     * The amount of time a script has to acknowlege an event by calling
     * propagate. If it fails to call propagate within this many milliseconds
     * of receiving the event, the script will be uninstalled.
     */
    ScriptHandler.PROPAGATION_TIMEOUT = 5000; // 5 seconds


    /*
     * A set of events that cannot be intercepted by scripts.
     */
    ScriptHandler.UNINTERCEPTABLE_EVENTS = {
      'command help': 'command help',
      'command about': 'command about',
      'command install': 'command install',
      'command uninstall': 'command uninstall',
      'command scripts': 'command scripts'
    };

    /*
     * Events that a script can listen for.
     */
    ScriptHandler.HOOKABLE_EVENTS = ['command', 'server', 'message'];

    /*
     * Events that are generated and sent by the script handler.
     */
    ScriptHandler.SCRIPTING_EVENTS = ['save', 'load'];

    function ScriptHandler() {
      this._handleMessage = __bind(this._handleMessage, this);
      this._handleEvent = __bind(this._handleEvent, this);
      ScriptHandler.__super__.constructor.apply(this, arguments);
      this._scripts = {};
      this._pendingEvents = {};
      this._eventCount = 0;
      this._emitters = [];
      this._propagationTimeoutTimerId = null;
      this._log = getLogger(this);
      addEventListener('message', this._handleMessage);
    }

    ScriptHandler.prototype.listenToScriptEvents = function(emitter) {
      return emitter.on('script_loaded', this.addScript);
    };

    /*
       * Add a script to the list of currently active scripts. Once added, the script
       * will receive events from the user and IRC server.
       * @param {Script} script
    */


    ScriptHandler.prototype.addScript = function(script) {
      return this._scripts[script.id] = script;
    };

    /**
     * Remove a script to the list of currently active scripts. Once removed,
     * the script will not longer receive events from the user or IRC server.
     * @param {Script} script
     */
    ScriptHandler.prototype.removeScript = function(script) {
      var eventId, _i, _len, _ref1;
      _ref1 = this._getPendingEventsForScript(script);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        eventId = _ref1[_i];
        this._stopHandlingEvent(script, eventId);
      }
      return delete this._scripts[script.id];
    };

    ScriptHandler.prototype._getPendingEventsForScript = function(script) {
      var id, pendingEventIds, pendingEventInfo, scriptWithPendingEvent, _i, _len, _ref1, _ref2;
      pendingEventIds = [];
      _ref1 = this._pendingEvents;
      for (id in _ref1) {
        pendingEventInfo = _ref1[id];
        _ref2 = pendingEventInfo.scripts;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          scriptWithPendingEvent = _ref2[_i];
          if (scriptWithPendingEvent.id === script.id) {
            pendingEventIds.push(id);
          }
        }
      }
      return pendingEventIds;
    };

    ScriptHandler.prototype.on = function(ev, cb) {
      if ((__indexOf.call(ScriptHandler.HOOKABLE_EVENTS, ev) >= 0) || (__indexOf.call(ScriptHandler.SCRIPTING_EVENTS, ev) >= 0)) {
        return ScriptHandler.__super__.on.call(this, ev, cb);
      } else {
        return this._forwardEvent(ev, cb);
      }
    };

    ScriptHandler.prototype._forwardEvent = function(ev, cb) {
      var emitter, _i, _len, _ref1, _results;
      _ref1 = this._emitters;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        emitter = _ref1[_i];
        _results.push(emitter.on(ev, cb));
      }
      return _results;
    };

    ScriptHandler.prototype.addEventsFrom = function(emitter) {
      var event, _i, _len, _ref1, _results;
      this._emitters.push(emitter);
      _ref1 = ScriptHandler.HOOKABLE_EVENTS;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        event = _ref1[_i];
        _results.push(emitter.on(event, this._handleEvent));
      }
      return _results;
    };

    ScriptHandler.prototype.removeEventsFrom = function(emitter) {
      var event, _i, _len, _ref1, _results;
      this._emitters.splice(this._emitters.indexOf(emitter), 1);
      _ref1 = ScriptHandler.HOOKABLE_EVENTS;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        event = _ref1[_i];
        _results.push(emitter.removeListener(event, this._handleEvent));
      }
      return _results;
    };

    ScriptHandler.prototype._handleEvent = function(event) {
      event.id = this._eventCount++;
      if (this._eventCanBeForwarded(event)) {
        this._offerEventToScripts(event);
      }
      if (!this._eventIsBeingHandled(event.id)) {
        return this._emitEvent(event);
      }
    };

    /*
       * Certain events are not allowed to be intercepted by scripts for security reasons.
       * @param {Event} event
       * @return {boolean} Returns true if the event can be forwarded to scripts.
    */


    ScriptHandler.prototype._eventCanBeForwarded = function(event) {
      return !(event.hook in ScriptHandler.UNINTERCEPTABLE_EVENTS);
    };

    ScriptHandler.prototype._offerEventToScripts = function(event) {
      var script, scriptId, _ref1, _results;
      _ref1 = this._scripts;
      _results = [];
      for (scriptId in _ref1) {
        script = _ref1[scriptId];
        if (script.shouldHandle(event)) {
          _results.push(this._sendEventToScript(event, script));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ScriptHandler.prototype._sendEventToScript = function(event, script) {
      script.postMessage(event);
      this._markEventAsPending(event, script);
      if (!this._propagationTimeoutTimerId) {
        this._propagationTimeoutTimerId = setTimeout(
          this._checkPropagationTimeout.bind(this), ScriptHandler.PROPAGATION_TIMEOUT);
      }
    };

    ScriptHandler.prototype._markEventAsPending = function(event, script) {
      if (!this._pendingEvents[event.id]) {
        this._pendingEvents[event.id] = {};
        this._pendingEvents[event.id].event = event;
        this._pendingEvents[event.id].scripts = [];
        this._pendingEvents[event.id].timestamp = Date.now();
      }
      return this._pendingEvents[event.id].scripts.push(script);
    };

    ScriptHandler.prototype._checkPropagationTimeout = function() {
      var unresponsiveScripts = this._getUnresponsiveScripts();
      for (var id in unresponsiveScripts) {
        var script = unresponsiveScripts[id];
        this._log('e', 'Removing unresponsive script ' + script.getName());
        this.removeScript(script);
      }
      this._propagationTimeoutTimerId = null;
      if (!this._isPendingEventQueueEmpty()) {
        var nextTimeout = this._getNextPendingEventTimeout();
        this._propagationTimeoutTimerId = setTimeout(
            this._checkPropagationTimeout.bind(this), nextTimeout);
      }
    }

    ScriptHandler.prototype._getUnresponsiveScripts = function() {
      var now = Date.now();
      var unresponsiveScripts = {}
      for (var id in this._pendingEvents) {
        var pendingEventInfo = this._pendingEvents[id];
        if (pendingEventInfo.timestamp + ScriptHandler.PROPAGATION_TIMEOUT <=
            now) {
          for (var i = 0; i < pendingEventInfo.scripts.length; i++) {
            var script = pendingEventInfo.scripts[i];
            unresponsiveScripts[script.id] = script;
          }
        }
      }
      return unresponsiveScripts;
    }

    ScriptHandler.prototype._isPendingEventQueueEmpty = function() {
      for (var id in this._pendingEvents) {
        return false;
      }
      return true;
    };

    ScriptHandler.prototype._getNextPendingEventTimeout = function() {
      var smallestTimestamp = Number.MAX_VALUE;
      for (var id in this._pendingEvents) {
        var pendingEventInfo = this._pendingEvents[id];
        if (pendingEventInfo.timestamp < smallestTimestamp) {
          smallestTimestamp = pendingEventInfo.timestamp;
        }
      }
      var nextTimeout = smallestTimestamp + ScriptHandler.PROPAGATION_TIMEOUT -
          Date.now();
      if (nextTimeout > ScriptHandler.PROPAGATION_TIMEOUT || nextTimeout <= 0) {
        nextTimeout = ScriptHandler.PROPAGATION_TIMEOUT;
      }
      return nextTimeout;
    }

    ScriptHandler.prototype._eventIsBeingHandled = function(eventId) {
      if (!(eventId in this._pendingEvents)) {
        return false;
      }
      return this._pendingEvents[eventId].scripts.length > 0;
    };

    ScriptHandler.prototype._handleMessage = function(message) {
      var event, script, type;
      event = message.data;
      script = window.script.Script.getScriptFromFrame(this._scripts, message.source);
      if (script == null) {
        return;
      }
      switch (event.type) {
        case 'hook_command':
        case 'hook_server':
        case 'hook_message':
          type = event.type.slice(5);
          return script.beginHandlingType(type, event.name);
        case 'command':
        case 'sevrer':
        case 'message':
          return this._emitEvent(Event.wrap(event));
        case 'propagate':
          return this._handleEventPropagation(script, event);
        case 'meta':
          return this._handleMetaData(script, event);
        case 'storage':
          return this._handleStorageRequest(script, event);
      }
    };

    ScriptHandler.prototype._handleEventPropagation = function(script, propagatationEvent) {
      var eventId, scriptsHandlingEvent, _ref1;
      eventId = (_ref1 = propagatationEvent.args) != null ? _ref1[0] : void 0;
      if (!this._eventIsBeingHandled(eventId)) {
        return;
      }
      scriptsHandlingEvent = this._pendingEvents[eventId].scripts;
      if (__indexOf.call(scriptsHandlingEvent, script) < 0) {
        return;
      }
      switch (propagatationEvent.name) {
        case 'none':
          return delete this._pendingEvents[eventId];
        case 'all':
          return this._stopHandlingEvent(script, eventId);
        default:
          return this._log('w', 'received unknown propagation type:', propagatationEvent.name);
      }
    };

    /*
       * Handles a meta data event, such as setting the script name.
       * @param {Script} script
       * @param {Event} event
    */


    ScriptHandler.prototype._handleMetaData = function(script, event) {
      var name, uniqueName;
      switch (event.name) {
        case 'name':
          name = event.args[0];
          if (!this._isValidName(name)) {
            return;
          }
          uniqueName = this._getUniqueName(name);
          return script.setName(uniqueName);
      }
    };

    /*
       * Returns true if the given script name contains only valid characters.
       * @param {string} name The script name.
       * @return {boolean}
    */


    ScriptHandler.prototype._isValidName = function(name) {
      return name && /^[a-zA-Z0-9\/_-]+$/.test(name);
    };

    /*
       * Appends numbers to the end of the script name until it is unique.
       * @param {string} name
    */


    ScriptHandler.prototype._getUniqueName = function(name) {
      var originalName, suffix;
      originalName = name = name.slice(0, +(ScriptHandler.MAX_NAME_LENGTH - 1) + 1 || 9e9);
      suffix = 1;
      while (__indexOf.call(this.getScriptNames(), name) >= 0) {
        suffix++;
        name = originalName + suffix;
      }
      return name;
    };

    /*
       * Handles loading or saving information to storage for the given script.
       * @param {Script} script The script wishing to use the storage.
       * @param {Event} event The event which contains the object to save.
    */


    ScriptHandler.prototype._handleStorageRequest = function(script, event) {
      var itemToSave,
        _this = this;
      switch (event.name) {
        case 'save':
          itemToSave = event.args[0];
          return this.emit('save', script.getName(), itemToSave);
        case 'load':
          return this.emit('load', script.getName(), function(item) {
            event = new Event('system', 'loaded', item);
            return script.postMessage(event);
          });
      }
    };

    ScriptHandler.prototype.storageChanged = function(script, change) {
      var event;
      event = new Event('system', 'storage_changed', change);
      return script.postMessage(event);
    };

    ScriptHandler.prototype.getScriptNames = function() {
      var id, script, _ref1, _results;
      _ref1 = this._scripts;
      _results = [];
      for (id in _ref1) {
        script = _ref1[id];
        _results.push(script.getName());
      }
      return _results;
    };

    ScriptHandler.prototype.getScriptByName = function(name) {
      var id, script, _ref1;
      _ref1 = this._scripts;
      for (id in _ref1) {
        script = _ref1[id];
        if (script.getName() === name) {
          return script;
        }
      }
      return null;
    };

    ScriptHandler.prototype._emitEvent = function(event) {
      return this.emit(event.type, event);
    };

    ScriptHandler.prototype._stopHandlingEvent = function(script, eventId) {
      var event, scriptsHandlingEvent;
      scriptsHandlingEvent = this._pendingEvents[eventId].scripts;
      removeFromArray(scriptsHandlingEvent, script);
      if (!this._eventIsBeingHandled(eventId)) {
        event = this._pendingEvents[eventId].event;
        delete this._pendingEvents[eventId];
        return this._emitEvent(event);
      }
    };

    ScriptHandler.prototype.tearDown = function() {
      return removeEventListener('message', this._handleEvent);
    };

    return ScriptHandler;

  })(EventEmitter);

  exports.ScriptHandler = ScriptHandler;

}).call(this);
